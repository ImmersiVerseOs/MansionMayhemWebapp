<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Voice Introduction | Mansion Mayhem</title>
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&family=Montserrat:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/css/navigation.css">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #0a0a0a;
      --bg-card: #111;
      --bg-elevated: #1a1a1a;
      --border: #2a2a2a;
      --text: #fff;
      --text-dim: #888;
      --gold: #d4af37;
      --purple: #8b5cf6;
      --rose: #e91e63;
      --success: #4caf50;
      --error: #ef4444;
    }
    body {
      font-family: 'Montserrat', sans-serif;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #0a0a0a 100%);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 32px 20px;
      position: relative;
      z-index: 2;
    }

    /* Spotlight Effect */
    .spotlight {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, rgba(212, 175, 55, 0.15) 0%, transparent 60%);
      pointer-events: none;
      z-index: 1;
      animation: pulse 4s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .page-title {
      font-family: 'Playfair Display', serif;
      font-size: 48px;
      color: var(--gold);
      text-align: center;
      margin-bottom: 12px;
      text-shadow: 0 0 40px rgba(212, 175, 55, 0.5);
    }
    .page-subtitle {
      text-align: center;
      color: var(--text-dim);
      font-size: 18px;
      margin-bottom: 40px;
    }

    .cast-selector {
      background: var(--bg-card);
      border: 2px solid var(--gold);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 32px;
      text-align: center;
    }
    .cast-selector h3 {
      color: var(--gold);
      margin-bottom: 16px;
      font-size: 20px;
    }
    .cast-selector select {
      width: 100%;
      max-width: 400px;
      padding: 14px;
      border: 2px solid var(--border);
      border-radius: 10px;
      background: var(--bg-elevated);
      color: var(--text);
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
    }
    .cast-selector select:focus {
      outline: none;
      border-color: var(--gold);
    }

    /* Main Card */
    .confessional-card {
      background: linear-gradient(135deg, rgba(212, 175, 55, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
      border: 3px solid var(--gold);
      border-radius: 24px;
      padding: 48px;
      text-align: center;
      position: relative;
      box-shadow: 0 20px 60px rgba(212, 175, 55, 0.3);
      animation: cardGlow 3s ease-in-out infinite;
    }
    @keyframes cardGlow {
      0%, 100% { box-shadow: 0 20px 60px rgba(212, 175, 55, 0.3); }
      50% { box-shadow: 0 20px 80px rgba(212, 175, 55, 0.5); }
    }

    /* Already Recorded State */
    .already-recorded {
      padding: 32px;
    }
    .already-recorded .icon {
      font-size: 80px;
      margin-bottom: 20px;
    }
    .already-recorded h2 {
      font-family: 'Playfair Display', serif;
      font-size: 32px;
      color: var(--success);
      margin-bottom: 12px;
    }
    .already-recorded .recorded-info {
      background: var(--bg-elevated);
      border-radius: 12px;
      padding: 20px;
      margin: 24px 0;
    }
    .already-recorded .duration {
      font-size: 18px;
      color: var(--gold);
      margin-bottom: 8px;
    }
    .already-recorded .recorded-at {
      font-size: 14px;
      color: var(--text-dim);
    }

    /* Instructions */
    .instructions {
      background: rgba(212, 175, 55, 0.1);
      border: 2px solid var(--gold);
      border-radius: 16px;
      padding: 24px;
      margin-bottom: 32px;
      text-align: left;
    }
    .instructions h3 {
      font-family: 'Playfair Display', serif;
      font-size: 24px;
      color: var(--gold);
      margin-bottom: 16px;
    }
    .instructions p {
      font-size: 16px;
      line-height: 1.6;
      margin-bottom: 16px;
    }
    .instructions ul {
      margin-left: 24px;
      line-height: 1.8;
    }
    .instructions li {
      color: var(--text-dim);
    }

    /* Microphone Icon */
    .mic-icon {
      font-size: 120px;
      margin: 24px 0;
      display: inline-block;
      transition: all 0.3s;
    }
    .mic-icon.recording {
      animation: micPulse 1s ease-in-out infinite;
      filter: drop-shadow(0 0 30px var(--rose));
    }
    @keyframes micPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Timer */
    .timer-container {
      position: relative;
      width: 200px;
      height: 200px;
      margin: 32px auto;
    }
    .progress-ring {
      transform: rotate(-90deg);
    }
    .progress-ring-circle {
      transition: stroke-dashoffset 0.1s linear;
      stroke: var(--gold);
      stroke-width: 8;
      fill: none;
    }
    .timer-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 42px;
      font-weight: 700;
      color: var(--gold);
      font-family: 'Playfair Display', serif;
    }
    .timer-label {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 14px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* Waveform */
    .waveform {
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      margin: 24px 0;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .waveform.active {
      opacity: 1;
    }
    .wave-bar {
      width: 4px;
      height: 20px;
      background: var(--gold);
      border-radius: 4px;
      animation: waveAnimation 1s ease-in-out infinite;
    }
    .wave-bar:nth-child(1) { animation-delay: 0s; }
    .wave-bar:nth-child(2) { animation-delay: 0.1s; }
    .wave-bar:nth-child(3) { animation-delay: 0.2s; }
    .wave-bar:nth-child(4) { animation-delay: 0.3s; }
    .wave-bar:nth-child(5) { animation-delay: 0.4s; }
    .wave-bar:nth-child(6) { animation-delay: 0.3s; }
    .wave-bar:nth-child(7) { animation-delay: 0.2s; }
    .wave-bar:nth-child(8) { animation-delay: 0.1s; }
    @keyframes waveAnimation {
      0%, 100% { height: 20px; }
      50% { height: 60px; }
    }

    /* Status Message */
    .status-message {
      font-size: 16px;
      margin: 20px 0;
      min-height: 24px;
      font-weight: 500;
    }
    .status-message.warning {
      color: var(--error);
    }
    .status-message.success {
      color: var(--success);
    }
    .status-message.info {
      color: var(--gold);
    }

    /* Audio Player */
    .audio-player {
      margin: 24px 0;
      display: none;
    }
    .audio-player.visible {
      display: block;
    }
    .audio-player audio {
      width: 100%;
      max-width: 500px;
      filter: hue-rotate(30deg);
    }

    /* Buttons */
    .btn-group {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin-top: 32px;
      flex-wrap: wrap;
    }
    .btn {
      padding: 16px 40px;
      border: none;
      border-radius: 12px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-family: 'Montserrat', sans-serif;
    }
    .btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--gold), var(--purple));
      color: white;
      box-shadow: 0 8px 24px rgba(212, 175, 55, 0.4);
    }
    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(212, 175, 55, 0.6);
    }
    .btn-primary.recording {
      background: linear-gradient(135deg, var(--error), var(--rose));
      animation: btnPulse 1s ease-in-out infinite;
    }
    @keyframes btnPulse {
      0%, 100% { box-shadow: 0 8px 24px rgba(239, 68, 68, 0.4); }
      50% { box-shadow: 0 12px 32px rgba(239, 68, 68, 0.8); }
    }
    .btn-secondary {
      background: var(--bg-elevated);
      color: var(--text);
      border: 2px solid var(--border);
    }
    .btn-secondary:hover:not(:disabled) {
      border-color: var(--gold);
      transform: translateY(-2px);
    }
    .btn-success {
      background: linear-gradient(135deg, var(--success), #059669);
      color: white;
    }
    .btn-success:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 12px 32px rgba(76, 175, 80, 0.6);
    }

    /* Loading State */
    .loading {
      text-align: center;
      padding: 60px 20px;
    }
    .loading-spinner {
      width: 60px;
      height: 60px;
      border: 4px solid var(--border);
      border-top-color: var(--gold);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Error State */
    .error-message {
      background: rgba(239, 68, 68, 0.1);
      border: 2px solid var(--error);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      color: var(--error);
    }

    /* Back Button */
    .back-btn {
      display: inline-block;
      color: var(--gold);
      text-decoration: none;
      margin-bottom: 24px;
      font-size: 16px;
      transition: all 0.3s;
    }
    .back-btn:hover {
      transform: translateX(-4px);
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="spotlight"></div>

  <!-- Navigation (loaded from include) -->
  <div id="globalNavPlaceholder"></div>
  <script>
    fetch('/includes/global-nav.html')
      .then(response => response.text())
      .then(data => {
        document.getElementById('globalNavPlaceholder').innerHTML = data;
      });
  </script>

  <div class="container">
    <a href="/lobby-dashboard.html" class="back-btn">‚Üê Back to Lobby</a>

    <h1 class="page-title">üé§ Confessional Booth</h1>
    <p class="page-subtitle">Make your grand entrance. This is your moment.</p>

    <!-- Cast Member Info (Auto-detected) -->
    <div id="cast-info" class="cast-selector" style="display: none;">
      <h3>üë§ Recording as:</h3>
      <div style="font-size: 24px; color: var(--gold); font-weight: 600; margin-top: 8px;" id="current-cast-name">
        Loading...
      </div>
    </div>

    <!-- Loading State -->
    <div id="loading-state" class="loading">
      <div class="loading-spinner"></div>
      <p style="color: var(--text-dim);">Loading your confessional...</p>
    </div>

    <!-- Error State -->
    <div id="error-state" class="hidden">
      <div class="error-message">
        <strong>Error:</strong> <span id="error-text"></span>
      </div>
    </div>

    <!-- Main Content -->
    <div id="main-content" class="hidden">

      <!-- Already Recorded State -->
      <div id="already-recorded-state" class="confessional-card already-recorded hidden">
        <div class="icon">‚úÖ</div>
        <h2>Introduction Recorded!</h2>
        <p style="color: var(--text-dim); margin-bottom: 24px;">Your introduction is ready for the other cast members.</p>

        <div class="recorded-info">
          <div class="duration" id="recorded-duration">Duration: --</div>
          <div class="recorded-at" id="recorded-at">Recorded: --</div>
        </div>

        <div class="audio-player visible">
          <audio id="recorded-audio" controls></audio>
        </div>

        <div class="btn-group">
          <button class="btn btn-secondary" onclick="reRecord()">üîÑ Record Again</button>
          <button class="btn btn-success" onclick="goToDashboard()">Continue to Lobby</button>
        </div>
      </div>

      <!-- Recording Interface -->
      <div id="recording-interface" class="confessional-card">

        <!-- Instructions -->
        <div class="instructions">
          <h3>üìã Your Mission</h3>
          <p><strong>Record your introduction for the other cast members (30-60 seconds).</strong></p>
          <p>Tell them:</p>
          <ul>
            <li>Who you are and what makes you unique</li>
            <li>Your personality and what you bring to the mansion</li>
            <li>What you're hoping to get out of this experience</li>
            <li>Why the other cast members should work with you</li>
          </ul>
        </div>

        <!-- Microphone Icon -->
        <div class="mic-icon" id="mic-icon">üé§</div>

        <!-- Timer with Progress Ring -->
        <div class="timer-container">
          <svg class="progress-ring" width="200" height="200">
            <circle
              class="progress-ring-circle"
              stroke="var(--border)"
              stroke-width="8"
              fill="none"
              r="90"
              cx="100"
              cy="100"
            />
            <circle
              id="progress-circle"
              class="progress-ring-circle"
              stroke="var(--gold)"
              stroke-width="8"
              fill="none"
              r="90"
              cx="100"
              cy="100"
              style="stroke-dasharray: 565.48; stroke-dashoffset: 565.48;"
            />
          </svg>
          <div class="timer-text" id="timer-text">00:00</div>
          <div class="timer-label" id="timer-label">Ready</div>
        </div>

        <!-- Waveform Animation -->
        <div class="waveform" id="waveform">
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
          <div class="wave-bar"></div>
        </div>

        <!-- Status Message -->
        <div class="status-message" id="status-message"></div>

        <!-- Audio Player (for preview) -->
        <div class="audio-player" id="audio-player">
          <audio id="preview-audio" controls></audio>
        </div>

        <!-- Buttons -->
        <div class="btn-group">
          <button id="record-btn" class="btn btn-primary" onclick="toggleRecording()">
            Start Recording
          </button>
          <button id="preview-btn" class="btn btn-secondary hidden" onclick="previewRecording()" disabled>
            Preview
          </button>
          <button id="rerecord-btn" class="btn btn-secondary hidden" onclick="rerecordAudio()">
            Re-record
          </button>
          <button id="submit-btn" class="btn btn-success hidden" onclick="submitIntroduction()" disabled>
            Submit Introduction
          </button>
        </div>
      </div>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script type="module" src="/js/supabase-client.js"></script>
  <script src="/js/navigation.js"></script>

  <script>
    // State
    let currentCastMemberId = localStorage.getItem('currentCastMemberId');
    let currentGameId = null;
    let mediaRecorder = null;
    let audioChunks = [];
    let recordedBlob = null;
    let startTime = null;
    let timerInterval = null;
    let existingIntroduction = null;

    const MIN_DURATION = 30; // seconds
    const MAX_DURATION = 60; // seconds

    // DOM Elements
    const loadingState = document.getElementById('loading-state');
    const errorState = document.getElementById('error-state');
    const mainContent = document.getElementById('main-content');
    const alreadyRecordedState = document.getElementById('already-recorded-state');
    const recordingInterface = document.getElementById('recording-interface');
    const micIcon = document.getElementById('mic-icon');
    const timerText = document.getElementById('timer-text');
    const timerLabel = document.getElementById('timer-label');
    const progressCircle = document.getElementById('progress-circle');
    const waveform = document.getElementById('waveform');
    const statusMessage = document.getElementById('status-message');
    const audioPlayer = document.getElementById('audio-player');
    const previewAudio = document.getElementById('preview-audio');
    const recordedAudio = document.getElementById('recorded-audio');
    const recordBtn = document.getElementById('record-btn');
    const previewBtn = document.getElementById('preview-btn');
    const rerecordBtn = document.getElementById('rerecord-btn');
    const submitBtn = document.getElementById('submit-btn');

    // Initialize
    window.addEventListener('DOMContentLoaded', async () => {
      // Show loading
      loadingState.classList.remove('hidden');
      errorState.classList.add('hidden');
      mainContent.classList.add('hidden');

      await loadCurrentCastMember();

      if (currentCastMemberId) {
        await checkExistingIntroduction();
      } else {
        loadingState.classList.add('hidden');
      }
    });

    // Load current user's cast member (SECURE - no manual selection)
    async function loadCurrentCastMember() {
      try {
        // Get authenticated user
        const { data: { user }, error: authError } = await window.supabaseClient.auth.getUser();

        if (authError || !user) {
          showError('You must be signed in to record an introduction');
          window.location.href = '/pages/sign-in.html';
          return;
        }

        // Get user's cast member record
        const { data: castMember, error } = await window.supabaseClient
          .from('cast_members')
          .select('id, full_name, display_name, status')
          .eq('user_id', user.id)
          .single();

        if (error || !castMember) {
          showError('Cast member profile not found. Please join a game first.');
          setTimeout(() => {
            window.location.href = '/pages/browse-games.html';
          }, 2000);
          return;
        }

        // Set current cast member (secure - from auth)
        currentCastMemberId = castMember.id;
        localStorage.setItem('currentCastMemberId', castMember.id);

        // Display cast member name immediately
        const castInfo = document.getElementById('cast-info');
        const castName = document.getElementById('current-cast-name');
        castName.textContent = `${castMember.display_name}`;
        castInfo.style.display = 'block';

        // Hide loading, show cast info right away
        loadingState.classList.add('hidden');

        console.log('‚úÖ Loaded cast member securely:', castMember.display_name);

      } catch (error) {
        console.error('Error loading cast member:', error);
        showError('Failed to load your profile: ' + error.message);
      }
    }

    // Check if introduction already exists
    async function checkExistingIntroduction() {
      try {
        // Don't hide cast info - user should always see their name
        errorState.classList.add('hidden');

        // Check for existing introduction
        const { data, error } = await window.supabaseClient
          .from('mm_voice_introductions')
          .select('*')
          .eq('cast_member_id', currentCastMemberId)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle();

        if (error) {
          throw error;
        }

        // Show main content (cast info already visible)
        mainContent.classList.remove('hidden');

        if (data) {
          // Already has introduction
          existingIntroduction = data;
          showAlreadyRecorded(data);
        } else {
          // Show recording interface
          alreadyRecordedState.classList.add('hidden');
          recordingInterface.classList.remove('hidden');
        }
      } catch (error) {
        console.error('Error checking introduction:', error);
        loadingState.classList.add('hidden');
        showError('Failed to load introduction status: ' + error.message);
      }
    }

    // Show already recorded state
    function showAlreadyRecorded(intro) {
      alreadyRecordedState.classList.remove('hidden');
      recordingInterface.classList.add('hidden');

      document.getElementById('recorded-duration').textContent =
        `Duration: ${Math.round(intro.duration_seconds)}s`;

      const recordedDate = new Date(intro.created_at);
      document.getElementById('recorded-at').textContent =
        `Recorded: ${recordedDate.toLocaleDateString()} at ${recordedDate.toLocaleTimeString()}`;

      // Set audio source (stored in voice-moderation-pending bucket)
      const audioUrl = window.supabaseClient.storage
        .from('voice-moderation-pending')
        .getPublicUrl(intro.storage_path).data.publicUrl;
      recordedAudio.src = audioUrl;
    }

    // Re-record
    function reRecord() {
      alreadyRecordedState.classList.add('hidden');
      recordingInterface.classList.remove('hidden');
      resetRecordingState();
    }

    // Toggle recording
    async function toggleRecording() {
      if (!currentCastMemberId) {
        showStatus('Please select a cast member first.', 'warning');
        return;
      }

      if (!mediaRecorder || mediaRecorder.state === 'inactive') {
        await startRecording();
      } else {
        stopRecording();
      }
    }

    // Start recording
    async function startRecording() {
      try {
        // Request microphone permission
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // Create MediaRecorder
        mediaRecorder = new MediaRecorder(stream);
        audioChunks = [];

        mediaRecorder.ondataavailable = (event) => {
          audioChunks.push(event.data);
        };

        mediaRecorder.onstop = () => {
          recordedBlob = new Blob(audioChunks, { type: 'audio/webm' });
          const audioUrl = URL.createObjectURL(recordedBlob);
          previewAudio.src = audioUrl;

          // Stop all tracks
          stream.getTracks().forEach(track => track.stop());
        };

        // Start recording
        mediaRecorder.start();
        startTime = Date.now();

        // Update UI
        recordBtn.textContent = 'Stop Recording';
        recordBtn.classList.add('recording');
        micIcon.classList.add('recording');
        waveform.classList.add('active');
        timerLabel.textContent = 'Recording...';
        showStatus('Recording in progress...', 'info');

        // Hide preview/submit buttons
        audioPlayer.classList.remove('visible');
        previewBtn.classList.add('hidden');
        rerecordBtn.classList.add('hidden');
        submitBtn.classList.add('hidden');

        // Start timer
        timerInterval = setInterval(updateTimer, 100);

      } catch (error) {
        console.error('Error starting recording:', error);
        showStatus('Failed to start recording. Please check microphone permissions.', 'warning');
      }
    }

    // Stop recording
    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === 'recording') {
        mediaRecorder.stop();
        clearInterval(timerInterval);

        const duration = (Date.now() - startTime) / 1000;

        // Update UI
        recordBtn.textContent = 'Start Recording';
        recordBtn.classList.remove('recording');
        recordBtn.classList.add('hidden'); // Hide record button after first recording
        micIcon.classList.remove('recording');
        waveform.classList.remove('active');
        timerLabel.textContent = 'Completed';

        // Check duration
        if (duration < MIN_DURATION) {
          showStatus(`Recording too short! Must be at least ${MIN_DURATION} seconds. (You recorded ${Math.round(duration)}s)`, 'warning');
          rerecordBtn.classList.remove('hidden');
          submitBtn.classList.add('hidden');
          submitBtn.disabled = true;
        } else if (duration > MAX_DURATION) {
          showStatus(`Recording too long! Must be under ${MAX_DURATION} seconds. (You recorded ${Math.round(duration)}s)`, 'warning');
          rerecordBtn.classList.remove('hidden');
          submitBtn.classList.add('hidden');
          submitBtn.disabled = true;
        } else {
          showStatus(`Perfect! ${Math.round(duration)} seconds. Preview your introduction below.`, 'success');
          previewBtn.classList.remove('hidden');
          previewBtn.disabled = false;
          rerecordBtn.classList.remove('hidden');
          submitBtn.classList.remove('hidden');
          submitBtn.disabled = false;
        }
      }
    }

    // Update timer
    function updateTimer() {
      const elapsed = (Date.now() - startTime) / 1000;
      const minutes = Math.floor(elapsed / 60);
      const seconds = Math.floor(elapsed % 60);

      timerText.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

      // Update progress circle
      const circumference = 2 * Math.PI * 90; // radius = 90
      const progress = Math.min(elapsed / MAX_DURATION, 1);
      const offset = circumference - (progress * circumference);
      progressCircle.style.strokeDashoffset = offset;

      // Change color as approaching max
      if (elapsed > MAX_DURATION * 0.9) {
        progressCircle.style.stroke = 'var(--error)';
      } else if (elapsed > MAX_DURATION * 0.75) {
        progressCircle.style.stroke = 'var(--rose)';
      } else {
        progressCircle.style.stroke = 'var(--gold)';
      }

      // Auto-stop at max duration
      if (elapsed >= MAX_DURATION) {
        stopRecording();
      }
    }

    // Preview recording
    function previewRecording() {
      audioPlayer.classList.add('visible');
      previewAudio.play();
      showStatus('Listening to your introduction...', 'info');
    }

    // Re-record
    function rerecordAudio() {
      resetRecordingState();
      showStatus('Ready to record again!', 'info');
    }

    // Reset recording state
    function resetRecordingState() {
      recordedBlob = null;
      audioChunks = [];
      timerText.textContent = '00:00';
      timerLabel.textContent = 'Ready';
      progressCircle.style.strokeDashoffset = 565.48;
      progressCircle.style.stroke = 'var(--gold)';
      audioPlayer.classList.remove('visible');
      previewAudio.src = '';
      recordBtn.textContent = 'Start Recording';
      recordBtn.classList.remove('recording', 'hidden');
      previewBtn.classList.add('hidden');
      rerecordBtn.classList.add('hidden');
      submitBtn.classList.add('hidden');
      submitBtn.disabled = true;
      showStatus('', '');
    }

    // Submit introduction
    async function submitIntroduction() {
      if (!recordedBlob || !currentCastMemberId) {
        showStatus('Invalid recording or cast member not selected.', 'warning');
        return;
      }

      try {
        submitBtn.disabled = true;
        submitBtn.textContent = 'Uploading...';
        showStatus('Uploading your introduction...', 'info');

        const duration = (Date.now() - startTime) / 1000;
        const timestamp = Date.now();
        const fileName = `${currentCastMemberId}-${timestamp}.webm`;

        // Upload to voice-introductions bucket
        const { data: uploadData, error: uploadError } = await window.supabaseClient.storage
          .from('voice-introductions')
          .upload(fileName, recordedBlob, {
            contentType: 'audio/webm',
            cacheControl: '3600',
            upsert: false
          });

        if (uploadError) throw uploadError;

        // Get URL for moderation review
        const { data: urlData } = window.supabaseClient.storage
          .from('voice-introductions')
          .getPublicUrl(fileName);

        // Delete old introduction if exists, then insert new one
        const { error: deleteError } = await window.supabaseClient
          .from('mm_voice_introductions')
          .delete()
          .eq('cast_member_id', currentCastMemberId);

        if (deleteError) {
          console.error('Delete error:', deleteError);
          throw new Error(`Failed to delete old introduction: ${deleteError.message}`);
        }

        // Insert new introduction
        const { data: dbData, error: dbError } = await window.supabaseClient
          .from('mm_voice_introductions')
          .insert({
            cast_member_id: currentCastMemberId,
            storage_path: fileName,
            duration_seconds: Math.round(duration),
            file_size_bytes: recordedBlob.size,
            mime_type: 'audio/webm',
            moderation_status: 'pending'
          })
          .select()
          .single();

        if (dbError) throw dbError;

        // Submit to moderation queue
        submitBtn.textContent = 'Submitting for review...';
        const { error: queueError } = await window.supabaseClient
          .rpc('submit_voice_for_moderation', {
            p_source_type: 'voice_introduction',
            p_source_table: 'mm_voice_introductions',
            p_source_record_id: dbData.id,
            p_submitter_user_id: (await window.supabaseClient.auth.getUser()).data.user.id,
            p_submitter_cast_id: currentCastMemberId,
            p_game_id: currentGameId,
            p_audio_url: urlData.publicUrl,
            p_duration_seconds: Math.round(duration),
            p_caption: null,
            p_priority: 0
          });

        if (queueError) {
          console.warn('Error adding to moderation queue:', queueError);
          // Continue anyway - introduction was saved
        }

        // Success!
        showStatus('Introduction submitted for review! You\'ll be notified when it\'s approved.', 'success');

        // Wait a moment then show the recorded state
        setTimeout(() => {
          existingIntroduction = dbData;
          showAlreadyRecorded(dbData);
        }, 1500);

      } catch (error) {
        console.error('Error submitting introduction:', error);
        showStatus('Failed to submit introduction: ' + error.message, 'warning');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Introduction';
      }
    }

    // Show status message
    function showStatus(message, type) {
      statusMessage.textContent = message;
      statusMessage.className = 'status-message ' + type;
    }

    // Show error
    function showError(message) {
      document.getElementById('error-text').textContent = message;
      errorState.classList.remove('hidden');
    }

    // Go to dashboard
    function goToDashboard() {
      window.location.href = '/lobby-dashboard.html';
    }
  </script>
</body>
</html>
